/*
 * stm32f407xx_i2c_driver.c
 *
 *  Created on: 2 nov. 2020
 *      Author: ange
 */

#include "stm32f407xx_i2c_driver.h"

/*
 * Define helper functions
 */
uint32_t rcc_get_pll_output_clk();
uint32_t rcc_get_pclk1_value();

void i2c_peri_clock_control(i2c_reg_t *arg_ptr_i2c,
		uint8_t arg_u8enable_or_disable) {
	switch ((int32_t) arg_ptr_i2c) {
	case (int32_t) I2C1:
		if (ENABLE == arg_u8enable_or_disable) {
			I2C1_PCLK_EN();
		} else if (DISABLE == arg_u8enable_or_disable) {
			I2C1_PCLK_DI();
		}
		break;
	case (int32_t) I2C2:
		if (ENABLE == arg_u8enable_or_disable) {
			I2C2_PCLK_EN();
		} else if (DISABLE == arg_u8enable_or_disable) {
			I2C2_PCLK_DI();
		}
		break;
	case (int32_t) I2C3:
		if (ENABLE == arg_u8enable_or_disable) {
			I2C3_PCLK_EN();
		} else if (DISABLE == arg_u8enable_or_disable) {
			I2C3_PCLK_DI();
		}
		break;
	default:
		break;
	}
}

void i2c_de_init(i2c_reg_t *arg_ptr_i2c) {
	switch ((uint32_t) arg_ptr_i2c) {
	case (uint32_t) I2C1:
		I2C1_RST();
		break;
	case (uint32_t) I2C2:
		I2C2_RST();
		break;
	case (uint32_t) I2C3:
		I2C3_RST();
		break;
	default:
		break;
	}
}

void i2c_irq_config(uint8_t arg_irq_number, uint8_t arg_irq_priority,
		uint8_t arg_enable_or_disable) {
	uint8_t loc_u8nvic_iser_index = arg_irq_number / 32U;
	uint8_t loc_u8nvic_iser_shift = arg_irq_number % 32U;
	if (ENABLE == arg_enable_or_disable) {
		NVIC_ISER[loc_u8nvic_iser_index] |= (SET << loc_u8nvic_iser_shift);
		uint8_t loc_u8nvic_iser_ipr_index = arg_irq_number / 4U;
		uint8_t loc_u8nvic_ipr_shift = (arg_irq_number % 4U) * 8U + 4U;
		NVIC_IPR[loc_u8nvic_iser_ipr_index] |= (arg_irq_priority
				<< loc_u8nvic_ipr_shift);
	} else if (DISABLE == arg_enable_or_disable) {
		NVIC_ICER[loc_u8nvic_iser_index] |= (SET << loc_u8nvic_iser_shift);
	}
}

void i2c_control(i2c_reg_t *arg_ptr_i2c, uint8_t arg_u8enable_or_disable) {
	if (ENABLE == arg_u8enable_or_disable) {
		arg_ptr_i2c->CR[1] |= (SET << I2C_CR1_PE);
	} else if (DISABLE == arg_u8enable_or_disable) {
		arg_ptr_i2c->CR[1] &= ~(SET << I2C_CR1_PE);
	}
}

void i2c_init(i2c_handle_t *arg_ptr_oi2c_handler) {
	/*!< Configure the mode (standard or fast)*/
	/*!< Configure the speed of the SCL : FREQ field of CR2*/
	arg_ptr_oi2c_handler->ptr_oi2c->CR[2] &= ~(SIX_BIT << I2C_CR2_FREQ);
	arg_ptr_oi2c_handler->ptr_oi2c->CR[2] |= (uint8_t) ((rcc_get_pclk1_value()
			/ 1000000U) & (SIX_BIT));

	/*!< Configure the device address mode (7 bits or 10 bits)*/
	arg_ptr_oi2c_handler->ptr_oi2c->OAR[1] &= ~(SET << I2C_OAR1_ADDMODE); // clear for 7 bits modes

	/*!< Configure the device own address (Applicable when the device is slave)*/
	arg_ptr_oi2c_handler->ptr_oi2c->OAR[1] &= ~(SEVEN_BIT << I2C_OAR1_ADD71);
	arg_ptr_oi2c_handler->ptr_oi2c->OAR[1] |=
			(arg_ptr_oi2c_handler->ptr_sconfig->device_addr & SEVEN_BIT);

	/*!< Reserved Bit 14 Should always be kept at 1 by software.*/
	arg_ptr_oi2c_handler->ptr_oi2c->OAR[1] |= (SET << I2C_OAR1_RSV14);

	/*!< Enable the Acking*/
	if (I2C_ACK_EN == arg_ptr_oi2c_handler->ptr_sconfig->ack_control) {
		arg_ptr_oi2c_handler->ptr_oi2c->CR[1] |= (SET << I2C_CR1_ACK);
	} else if (I2C_ACK_DI == arg_ptr_oi2c_handler->ptr_sconfig->ack_control) {
		arg_ptr_oi2c_handler->ptr_oi2c->CR[1] &= ~(SET << I2C_CR1_ACK);
	}

	/*!< CCR calculation*/
	uint16_t loc_u16ccr_value = 0U;
	if (arg_ptr_oi2c_handler->ptr_sconfig->scl_speed <= I2C_SCL_SPEED_SM) {
		/*!< standard mode*/
		loc_u16ccr_value = (uint16_t)(rcc_get_pclk1_value() / (2 * arg_ptr_oi2c_handler->ptr_sconfig->scl_speed));
		arg_ptr_oi2c_handler->ptr_oi2c->CCR &= ~(TWELVEBIT << I2C_CCR_CCR);
				arg_ptr_oi2c_handler->ptr_oi2c->CCR |= (loc_u16ccr_value & TWELVEBIT);
	} else {
		/*!< fast mode*/
	}

	/*!< Configure the mode rise time for I2C*/
}

uint32_t rcc_get_pclk1_value() {
	uint32_t loc_u32pclk1 = 0U;
	uint8_t loc_u8clk_src = (uint8_t) ((RCC->CFGR >> RCC_CFGR_SW1) & TWO_BIT);
	/*!< find the clock source*/
	if (IS_HSE_SYSTEM_CLK == loc_u8clk_src) {
		loc_u32pclk1 = 8000000U; // 8MHZ
	} else if (IS_HSI_SYSTEM_CLK == loc_u8clk_src) {
		loc_u32pclk1 = 16000000U; //16MHZ
	} else if (IS_PLL_SYSTEM_CLK == loc_u8clk_src) {
		loc_u32pclk1 = rcc_get_pll_output_clk();
	}

	uint8_t loc_u8AHB_prescaler = (uint8_t) ((RCC->CFGR >> RCC_CFGR_HPRE)
			& FOUR_BIT);
	if (loc_u8AHB_prescaler > 7U) {
		uint16_t loc_au16AHBprescaler_div[] = { 2U, 4U, 8U, 16U, 64U, 128U,
				256U, 512U };
		loc_u32pclk1 /=
				loc_au16AHBprescaler_div[loc_u8AHB_prescaler & THREE_BIT];
	}

	uint8_t loc_u8APB1_prescaler = (uint8_t) ((RCC->CFGR >> RCC_CFGR_PPRE1)
			& THREE_BIT);
	if (loc_u8APB1_prescaler > 3U) {
		uint8_t loc_u8APB1_prescaler_div[] = { 2U, 4U, 8U, 16U };
		loc_u32pclk1 /= loc_u8APB1_prescaler_div[loc_u8AHB_prescaler & TWO_BIT];
	}

	return loc_u32pclk1;
}

uint32_t rcc_get_pll_output_clk() {
	uint32_t loc_u32pll_output_clk = 0U;
	return loc_u32pll_output_clk;
}
