/*
 * stm32f407xx_usart_driver.c
 *
 *  Created on: 16 nov. 2020
 *      Author: msw
 */

#include "stm32f407xx_usart_driver.h"

void usart_control_peripheral(usart_reg_t *arg_ptr_usart, uint8_t arg_u8enable_or_disable) {
	if (ENABLE == arg_u8enable_or_disable) {
		arg_ptr_usart->CR1 |= (SET << USART_CR1_UE);
	} else if (DISABLE == arg_u8enable_or_disable) {
		arg_ptr_usart->CR1 &= ~(SET << USART_CR1_UE);
	}
}

void usart_control_clock(usart_reg_t *arg_ptr_usart,
		uint8_t arg_u8enable_or_disable) {
	switch ((int32_t) arg_ptr_usart) {
	case (int32_t) USART1:
			if (ENABLE == arg_u8enable_or_disable) {
				USART1_PCLK_EN();
			} else if (DISABLE == arg_u8enable_or_disable) {
				USART1_PCLK_DI();
			}
	break;
	case (int32_t) USART2:
			if (ENABLE == arg_u8enable_or_disable) {
				USART2_PCLK_EN();
			} else if (DISABLE == arg_u8enable_or_disable) {
				USART2_PCLK_DI();
			}
	break;
	case (int32_t) USART3:
			if (ENABLE == arg_u8enable_or_disable) {
				USART3_PCLK_EN();
			} else if (DISABLE == arg_u8enable_or_disable) {
				USART3_PCLK_DI();
			}
	break;
	case (int32_t) UART4:
			if (ENABLE == arg_u8enable_or_disable) {
				UART4_PCLK_EN();
			} else if (DISABLE == arg_u8enable_or_disable) {
				UART4_PCLK_DI();
			}
	break;
	case (int32_t) UART5:
			if (ENABLE == arg_u8enable_or_disable) {
				UART5_PCLK_EN();
			} else if (DISABLE == arg_u8enable_or_disable) {
				UART5_PCLK_DI();
			}
	break;
	case (int32_t) USART6:
			if (ENABLE == arg_u8enable_or_disable) {
				USART6_PCLK_EN();
			} else if (DISABLE == arg_u8enable_or_disable) {
				USART6_PCLK_DI();
			}
	break;
	case (int32_t) UART7:
			if (ENABLE == arg_u8enable_or_disable) {
				UART7_PCLK_EN();
			} else if (DISABLE == arg_u8enable_or_disable) {
				UART7_PCLK_DI();
			}
	break;
	case (int32_t) UART8:
			if (ENABLE == arg_u8enable_or_disable) {
				UART8_PCLK_EN();
			} else if (DISABLE == arg_u8enable_or_disable) {
				UART8_PCLK_DI();
			}
	break;
	default:
		break;
	}
}

uint8_t usart_get_flag_status(usart_reg_t *arg_ptr_usart, uint32_t arg_u8flag) {
	uint8_t loc_u8flag = 0;
	if (arg_ptr_usart->SR & arg_u8flag) {
		loc_u8flag = FLAG_SET;
	} else {
		loc_u8flag = FLAG_RESET;
	}
	return loc_u8flag;
}

void usart_clear_flag_status(usart_reg_t *arg_ptr_usart, uint32_t arg_u32flag) {
	switch (arg_u32flag) {
	case USART_FLAG_CTS:
	case USART_FLAG_LBD:
	{
		arg_ptr_usart->SR &= ~arg_u32flag;
	}

	break;
	case USART_FLAG_TXE:
	{
		arg_ptr_usart->DR |= 0xFFFF;
	}
	break;
	case USART_FLAG_TC:
	{
		uint32_t loc_u32dummy_read = arg_ptr_usart->SR;
		arg_ptr_usart->DR &= 0xFFFF;
		(void) loc_u32dummy_read;
	}
	break;
	case USART_FLAG_RXNE:
	{
		uint32_t loc_u32dummy_read = arg_ptr_usart->SR;
		(void) loc_u32dummy_read;
	}
	break;
	case USART_FLAG_IDLE:
	case USART_FLAG_ORE:
	case USART_FLAG_NF:
	case USART_FLAG_FE:
	case USART_FLAG_PE:
	{
		uint32_t loc_u32dummy_read = arg_ptr_usart->SR;
		loc_u32dummy_read = arg_ptr_usart->DR;
		(void) loc_u32dummy_read;
	}
	break;
	default:
		break;
	}
}

void usart_irq_config(uint8_t arg_irq_number, uint8_t arg_irq_priority,
		uint8_t arg_enable_or_disable) {
	uint8_t loc_u8nvic_iser_index = arg_irq_number / 32U;
	uint8_t loc_u8nvic_iser_shift = arg_irq_number % 32U;
	if (ENABLE == arg_enable_or_disable) {
		NVIC_ISER[loc_u8nvic_iser_index] |= (SET << loc_u8nvic_iser_shift);
		uint8_t loc_u8nvic_iser_ipr_index = arg_irq_number / 4U;
		uint8_t loc_u8nvic_ipr_shift = (arg_irq_number % 4U) * 8U + 4U;
		NVIC_IPR[loc_u8nvic_iser_ipr_index] |= (arg_irq_priority
				<< loc_u8nvic_ipr_shift);
	} else if (DISABLE == arg_enable_or_disable) {
		NVIC_ICER[loc_u8nvic_iser_index] |= (SET << loc_u8nvic_iser_shift);
	}
}

void usart_init(usart_handle_t *arg_pousart_handler) {
	uint32_t loc_u32temp_reg = 0U;
	/*!< ****************************** CR1 REG ****************************** >*/
	/*!< enable the clock for the given uart >*/
	usart_control_clock(arg_pousart_handler->m_poi2c_reg, ENABLE);

	/*!< Enable Tx & Rx engin according to the usart_mode configuration >*/
	if (USART_MODE_RX == arg_pousart_handler->m_pousart_config_t->m_u8mode) {
		loc_u32temp_reg |= (SET << USART_CR1_RE);
	} else if (USART_MODE_TX == arg_pousart_handler->m_pousart_config_t->m_u8mode) {
		loc_u32temp_reg |= (SET << USART_CR1_TE);
	} else if (USART_MODE_TXRX== arg_pousart_handler->m_pousart_config_t->m_u8mode) {
		loc_u32temp_reg |= ((SET << USART_CR1_RE) | (SET << USART_CR1_TE));
	}

	/*!< configure the word length >*/
	loc_u32temp_reg |= (arg_pousart_handler->m_pousart_config_t->m_u8word_length << USART_CR1_M);

	/*!< Parity control bit >*/
	if (arg_pousart_handler->m_pousart_config_t->m_u8parity_control != USART_PARITY_DI) {
		loc_u32temp_reg |= (SET >> USART_CR1_PCE);
		if(USART_PARITY_ODD == arg_pousart_handler->m_pousart_config_t->m_u8parity_control) {
			loc_u32temp_reg |= (SET << USART_CR1_PS);
		}
	}

	arg_pousart_handler->m_poi2c_reg->CR1 = loc_u32temp_reg;

	/*!< ****************************** CR2 REG ****************************** >*/
	loc_u32temp_reg = 0U;
	/*!< number of stop bit >*/
	loc_u32temp_reg |= (arg_pousart_handler->m_pousart_config_t->m_u8nomber_of_stop_bit << USART_CR2_STOP);

	arg_pousart_handler->m_poi2c_reg->CR2 = loc_u32temp_reg;

	/*!< ****************************** CR3 REG ****************************** >*/
	loc_u32temp_reg = 0U;
	/*!< Hw flow control >*/
	if (USART_HW_FLWO_CTRL_CTS == arg_pousart_handler->m_pousart_config_t->m_u8hw_flow_control) {
		loc_u32temp_reg |= (SET << USART_CR3_CTSE);
	} else if (USART_HW_FLWO_CTRL_RTS == arg_pousart_handler->m_pousart_config_t->m_u8hw_flow_control) {
		loc_u32temp_reg |= (SET << USART_CR3_RTSE);
	} else if (USART_HW_FLWO_CTRL_CTS_RTS == arg_pousart_handler->m_pousart_config_t->m_u8hw_flow_control) {
		loc_u32temp_reg |= ((SET << USART_CR3_CTSE) | (SET << USART_CR3_RTSE));
	}

	arg_pousart_handler->m_poi2c_reg->CR3 = loc_u32temp_reg;

	/*!< Implement  >*/

}

void usart_de_init(usart_reg_t *arg_pusart) {
	switch ((uint32_t) arg_pusart) {
	case (uint32_t) USART1:
			USART1_RST();
	break;
	case (uint32_t) USART2:
			USART2_RST();
	break;
	case (uint32_t) USART3:
			USART3_RST();
	break;
	case (uint32_t) UART4:
			UART4_RST();
	break;
	case (uint32_t) UART5:
			UART5_RST();
	break;
	case (uint32_t) USART6:
			USART6_RST();
	break;
	case (uint32_t) UART7:
			UART7_RST();
	break;
	case (uint32_t) UART8:
			UART8_RST();
	break;
	default:
		break;
	}
}

void usart_send_data(usart_reg_t *arg_pusart,
		uint8_t *arg_pu8tx_buffer, uint32_t arg_u32len) {
	/*!< loop over until arg_u32len number of byte is transferred >*/
	for (uint32_t loc_u32bit_transferd = 0; loc_u32bit_transferd < arg_u32len; ++ loc_u32bit_transferd) {
		/*!< Wait until TXE FLAG is set in SR >*/
		while (FLAG_RESET == usart_get_flag_status(arg_pusart, USART_FLAG_TXE));

		/*!< load the DR with 1 byte of data >*/
		arg_pusart->DR = *arg_pu8tx_buffer;
		++arg_pu8tx_buffer;
	}

	/*!< Wait until TC FLAG is set in SR >*/
	while (FLAG_RESET == usart_get_flag_status(arg_pusart, USART_FLAG_TC));
}

void usart_receive_data(usart_reg_t *arg_pusart,
		uint8_t *arg_pu8tx_buffer, uint32_t arg_u32len) {
	/*!< Wait until RXNE flag is set >*/
	while(FLAG_RESET == usart_get_flag_status(arg_pusart, USART_FLAG_RXNE));

	/*!<  >*/
	/*!<  >*/
}


