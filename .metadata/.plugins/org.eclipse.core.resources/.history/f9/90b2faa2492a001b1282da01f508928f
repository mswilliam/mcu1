/*
 * stm32f407xx_usart_driver.c
 *
 *  Created on: 16 nov. 2020
 *      Author: msw
 */

#include "stm32f407xx_usart_driver.h"

void usart_control_peripheral(usart_reg_t *arg_ptr_usart, uint8_t arg_u8enable_or_disable) {
	if (ENABLE == arg_u8enable_or_disable) {
		arg_ptr_usart->CR1 |= (SET << USART_CR1_UE);
	} else if (DISABLE == arg_u8enable_or_disable) {
		arg_ptr_usart->CR1 &= ~(SET << USART_CR1_UE);
	}
}

void usart_control_clock(usart_reg_t *arg_ptr_usart,
		uint8_t arg_u8enable_or_disable) {
	switch ((int32_t) arg_ptr_usart) {
	case (int32_t) USART1:
			if (ENABLE == arg_u8enable_or_disable) {
				USART1_PCLK_EN();
			} else if (DISABLE == arg_u8enable_or_disable) {
				USART1_PCLK_DI();
			}
	break;
	case (int32_t) USART2:
			if (ENABLE == arg_u8enable_or_disable) {
				USART2_PCLK_EN();
			} else if (DISABLE == arg_u8enable_or_disable) {
				USART2_PCLK_DI();
			}
	break;
	case (int32_t) USART3:
			if (ENABLE == arg_u8enable_or_disable) {
				USART3_PCLK_EN();
			} else if (DISABLE == arg_u8enable_or_disable) {
				USART3_PCLK_DI();
			}
	break;
	case (int32_t) UART4:
			if (ENABLE == arg_u8enable_or_disable) {
				UART4_PCLK_EN();
			} else if (DISABLE == arg_u8enable_or_disable) {
				UART4_PCLK_DI();
			}
	break;
	case (int32_t) UART5:
			if (ENABLE == arg_u8enable_or_disable) {
				UART5_PCLK_EN();
			} else if (DISABLE == arg_u8enable_or_disable) {
				UART5_PCLK_DI();
			}
	break;
	case (int32_t) USART6:
			if (ENABLE == arg_u8enable_or_disable) {
				USART6_PCLK_EN();
			} else if (DISABLE == arg_u8enable_or_disable) {
				USART6_PCLK_DI();
			}
	break;
	case (int32_t) UART7:
			if (ENABLE == arg_u8enable_or_disable) {
				UART7_PCLK_EN();
			} else if (DISABLE == arg_u8enable_or_disable) {
				UART7_PCLK_DI();
			}
	break;
	case (int32_t) UART8:
			if (ENABLE == arg_u8enable_or_disable) {
				UART8_PCLK_EN();
			} else if (DISABLE == arg_u8enable_or_disable) {
				UART8_PCLK_DI();
			}
	break;
	default:
		break;
	}
}

uint8_t usart_get_flag_status(usart_reg_t *arg_ptr_usart, uint32_t arg_u8flag) {
	uint8_t loc_u8flag = 0;
	if (arg_ptr_usart->SR & arg_u8flag) {
		loc_u8flag = FLAG_SET;
	} else {
		loc_u8flag = FLAG_RESET;
	}
	return loc_u8flag;
}

void usart_clear_flag_status(usart_reg_t *arg_ptr_usart, uint32_t arg_u32flag) {
	switch (arg_u32flag) {
	case USART_FLAG_CTS:
	case USART_FLAG_LBD:
	{
		arg_ptr_usart->SR &= ~arg_u32flag;
	}

	break;
	case USART_FLAG_TXE:
	{
		arg_ptr_usart->DR |= 0xFFFF;
	}
	break;
	case USART_FLAG_TC:
	{
		uint32_t loc_u32dummy_read = arg_ptr_usart->SR;
		arg_ptr_usart->DR &= 0xFFFF;
		(void) loc_u32dummy_read;
	}
	break;
	case USART_FLAG_RXNE:
	{
		uint32_t loc_u32dummy_read = arg_ptr_usart->SR;
		(void) loc_u32dummy_read;
	}
	break;
	case USART_FLAG_IDLE:
	case USART_FLAG_ORE:
	case USART_FLAG_NF:
	case USART_FLAG_FE:
	case USART_FLAG_PE:
	{
		uint32_t loc_u32dummy_read = arg_ptr_usart->SR;
		loc_u32dummy_read = arg_ptr_usart->DR;
		(void) loc_u32dummy_read;
	}
	break;
	default:
		break;
	}
}

void usart_irq_config(uint8_t arg_irq_number, uint8_t arg_irq_priority,
		uint8_t arg_enable_or_disable) {
	uint8_t loc_u8nvic_iser_index = arg_irq_number / 32U;
	uint8_t loc_u8nvic_iser_shift = arg_irq_number % 32U;
	if (ENABLE == arg_enable_or_disable) {
		NVIC_ISER[loc_u8nvic_iser_index] |= (SET << loc_u8nvic_iser_shift);
		uint8_t loc_u8nvic_iser_ipr_index = arg_irq_number / 4U;
		uint8_t loc_u8nvic_ipr_shift = (arg_irq_number % 4U) * 8U + 4U;
		NVIC_IPR[loc_u8nvic_iser_ipr_index] |= (arg_irq_priority
				<< loc_u8nvic_ipr_shift);
	} else if (DISABLE == arg_enable_or_disable) {
		NVIC_ICER[loc_u8nvic_iser_index] |= (SET << loc_u8nvic_iser_shift);
	}
}

void usart_init(usart_handle_t *arg_pousart_handler) {
	uint32_t loc_u32temp_reg = 0U;
	/*!< enable the clock for the given uart >*/
	usart_control_clock(arg_pousart_handler->m_poi2c_reg, ENABLE);

	/*!< Enable Tx & Rx engin according to the usart_mode configuration >*/
	if (USART_MODE_RX == arg_pousart_handler->m_pousart_config_t->m_u8mode) {
		loc_u32temp_reg |= (SET << USART_CR1_RE);
	} else if (USART_MODE_TX == arg_pousart_handler->m_pousart_config_t->m_u8mode) {
		loc_u32temp_reg |= (SET << USART_CR1_TE);
	} else if (USART_MODE_TXRX== arg_pousart_handler->m_pousart_config_t->m_u8mode) {
		loc_u32temp_reg |= (SET << USART_CR1_RE);
		loc_u32temp_reg |= (SET << USART_CR1_TE);
	}

	arg_pousart_handler->m_poi2c_reg->CR1 = loc_u32temp_reg;

	/*!<  >*/
	/*!<  >*/

}

void usart_de_init(usart_reg_t *arg_pusart) {
	switch ((uint32_t) arg_pusart) {
	case (uint32_t) USART1:
			USART1_RST();
	break;
	case (uint32_t) USART2:
			USART2_RST();
	break;
	case (uint32_t) USART3:
			USART3_RST();
	break;
	case (uint32_t) UART4:
			UART4_RST();
	break;
	case (uint32_t) UART5:
			UART5_RST();
	break;
	case (uint32_t) USART6:
			USART6_RST();
	break;
	case (uint32_t) UART7:
			UART7_RST();
	break;
	case (uint32_t) UART8:
			UART8_RST();
	break;
	default:
		break;
	}
}




